<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://damao33.github.io</id>
    <title>damao_33</title>
    <updated>2020-05-11T05:49:47.046Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://damao33.github.io"/>
    <link rel="self" href="https://damao33.github.io/atom.xml"/>
    <subtitle>汪汪汪汪汪</subtitle>
    <logo>https://damao33.github.io/images/avatar.png</logo>
    <icon>https://damao33.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, damao_33</rights>
    <entry>
        <title type="html"><![CDATA[如何使用Gridea管理个人博客--简易版]]></title>
        <id>https://damao33.github.io/post/ru-he-shi-yong-gridea-guan-li-ge-ren-bo-ke/</id>
        <link href="https://damao33.github.io/post/ru-he-shi-yong-gridea-guan-li-ge-ren-bo-ke/">
        </link>
        <updated>2020-05-11T04:17:50.000Z</updated>
        <content type="html"><![CDATA[<p>在公众号topbook被安利了Gridea这个写博客的软件后，想起自己又好久没有写博客，于是顺便趁着上手Gridea的机会，好好整顿一下博客</p>
<h2 id="建立github仓库">建立github仓库</h2>
<p>首先到github上创建一个新的仓库，仓库名为 「用户名.github.io」，后续就可以用这个仓库名作为<strong>博客访问域名</strong></p>
<figure data-type="image" tabindex="1"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133416265-1974237194.png" alt="" loading="lazy"></figure>
<p>创建仓库后点击仓库的settings，拉到页面最下端检查自己是否开启了github pages</p>
<p><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133537524-1830869770.png" alt="" loading="lazy"><br>
<img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133600001-1804370455.png" alt="" loading="lazy"></p>
<p>到这里，就成功建立了内容为空的博客页面，访问域名是你的仓库名</p>
<h2 id="建立github-token">建立github token</h2>
<p>点击右上角头像的settings，选择菜单最下面的developer settings</p>
<figure data-type="image" tabindex="2"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133620432-1166258344.png" alt="" loading="lazy"></figure>
<p>选择personal access tokens，并生成一个新的token</p>
<figure data-type="image" tabindex="3"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133634799-1325132850.png" alt="" loading="lazy"></figure>
<p>新建token时填完名称后把repo勾选起来，然后到页面最下面点击生成</p>
<figure data-type="image" tabindex="4"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133642980-772495378.png" alt="" loading="lazy"></figure>
<p>生成成功后，这个页面一定不能关闭，根据提示，你的这个令牌关掉页面后你再也找不到了</p>
<figure data-type="image" tabindex="5"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133651950-1371172610.png" alt="" loading="lazy"></figure>
<h2 id="配置gridea">配置Gridea</h2>
<p>在远程选项里，把能填的信息都填上去，令牌就是你上面生成token获得的个人令牌</p>
<figure data-type="image" tabindex="6"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133659290-333083240.png" alt="" loading="lazy"></figure>
<p>保存后，点击左下角的同步，再通过域名打开你的博客，或者直接点击左下角小地球，就能看到你通过Gridea部署的博客啦</p>
<figure data-type="image" tabindex="7"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133705466-1843821433.png" alt="" loading="lazy"></figure>
<h2 id="使用gridea">使用Gridea</h2>
<p>关于Gridea的使用还是比较“傻瓜式”的，你可以在清晰简洁的界面里放上你想放的东西，然后点击同步，就可以在博客中看到啦。</p>
<p>Gridea有开放的主题配置环境，你可以在主题商城中选择用户开发或者开发者开发的主题</p>
<p>值得一提的是，Gridea 是一个静态博客写作客户端，所以每次写完内容不要忘记点击同步。</p>
<h2 id="官网">官网</h2>
<p><a href="https://gridea.dev/">https://gridea.dev/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA面向对象编程课程设计——多人扫雷对战]]></title>
        <id>https://damao33.github.io/post/java_mine_sweeper/</id>
        <link href="https://damao33.github.io/post/java_mine_sweeper/">
        </link>
        <updated>2020-01-09T16:02:06.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="一团队课程设计博客链接">一.团队课程设计博客链接</h1>
<p><a href="https://www.cnblogs.com/ye12892/p/12174140.html">JAVA面向对象编程课程设计——多人扫雷对战</a></p>
<h1 id="二个人负责模块和任务说明">二.个人负责模块和任务说明</h1>
<ul>
<li>负责服务器和客户端信息传输</li>
<li>用DAO模式对MySQL进行操作</li>
<li>在客户端将信息在各个界面间传输</li>
</ul>
<hr>
<h1 id="三自己的代码提交记录截图">三.自己的代码提交记录截图</h1>
<p><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110002959991-237554488.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003015038-1477407246.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003016203-1706076234.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110002918055-7983445.png" alt="" loading="lazy"></figure>
<hr>
<h1 id="四自己负责模块或任务详细说明">四.自己负责模块或任务详细说明</h1>
<ul>
<li>客户端登陆、注册、设置信息时和服务器的数据交互：</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003122458-173207921.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003134328-287150250.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003154568-1652655139.png" alt="" loading="lazy"></p>
<p>通过DAO模式将在界面获得的信息与服务器数据库上的信息进行交互，以实现用户登陆、注册、编辑信息的功能。</p>
<ul>
<li>获取游戏操作信息，将玩家的游戏操作传到游戏界面以便于GUI显示：</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003315061-905209868.png" alt="" loading="lazy"></figure>
<p>客户端将点击在哪个方块的信息发送到服务器，服务器将该消息发给所有连接的用户，所有用户收到该消息后在游戏界面对应位置显示出该玩家目前游戏进度。</p>
<ul>
<li>客户端接收到消息时将消息传到相应界面以便于GUI的实时显示：</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003331635-1150829104.png" alt="" loading="lazy"></figure>
<p>用户每次操作（登陆、进入游戏房间、进行游戏操作、退出等）都会通过服务器发送给所有已连接用户，用户客户端通过判断该操作信息的类型，将该信息传递给对应的GUI面板以便实时显示信息。</p>
<hr>
<p>##主要代码</p>
<ul>
<li>服务器接收并转发信息</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110000802575-1919729382.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110000848061-266985498.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001641969-1208466272.png" alt="" loading="lazy"></p>
<p>服务器端用ServerSocket监听端口，当有用户通过Socket连接时启动一个新的线程来处理该用户发送过来的消息。</p>
<p>**服务器如何获</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="一团队课程设计博客链接">一.团队课程设计博客链接</h1>
<p><a href="https://www.cnblogs.com/ye12892/p/12174140.html">JAVA面向对象编程课程设计——多人扫雷对战</a></p>
<h1 id="二个人负责模块和任务说明">二.个人负责模块和任务说明</h1>
<ul>
<li>负责服务器和客户端信息传输</li>
<li>用DAO模式对MySQL进行操作</li>
<li>在客户端将信息在各个界面间传输</li>
</ul>
<hr>
<h1 id="三自己的代码提交记录截图">三.自己的代码提交记录截图</h1>
<p><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110002959991-237554488.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003015038-1477407246.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003016203-1706076234.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110002918055-7983445.png" alt="" loading="lazy"></figure>
<hr>
<h1 id="四自己负责模块或任务详细说明">四.自己负责模块或任务详细说明</h1>
<ul>
<li>客户端登陆、注册、设置信息时和服务器的数据交互：</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003122458-173207921.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003134328-287150250.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003154568-1652655139.png" alt="" loading="lazy"></p>
<p>通过DAO模式将在界面获得的信息与服务器数据库上的信息进行交互，以实现用户登陆、注册、编辑信息的功能。</p>
<ul>
<li>获取游戏操作信息，将玩家的游戏操作传到游戏界面以便于GUI显示：</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003315061-905209868.png" alt="" loading="lazy"></figure>
<p>客户端将点击在哪个方块的信息发送到服务器，服务器将该消息发给所有连接的用户，所有用户收到该消息后在游戏界面对应位置显示出该玩家目前游戏进度。</p>
<ul>
<li>客户端接收到消息时将消息传到相应界面以便于GUI的实时显示：</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003331635-1150829104.png" alt="" loading="lazy"></figure>
<p>用户每次操作（登陆、进入游戏房间、进行游戏操作、退出等）都会通过服务器发送给所有已连接用户，用户客户端通过判断该操作信息的类型，将该信息传递给对应的GUI面板以便实时显示信息。</p>
<hr>
<p>##主要代码</p>
<ul>
<li>服务器接收并转发信息</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110000802575-1919729382.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110000848061-266985498.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001641969-1208466272.png" alt="" loading="lazy"></p>
<p>服务器端用ServerSocket监听端口，当有用户通过Socket连接时启动一个新的线程来处理该用户发送过来的消息。</p>
<p>**服务器如何获</p>
<!-- more -->
<!-- more -->
<p>得所有已连接用户？**</p>
<p>服务器有一个HashSet型静态属性来存放每个连接进来的线程，而线程有getUser()，通过遍历这个Set就能实现把消息发给所有用户的方法（sendToAll）。</p>
<ul>
<li>客户端接收并向界面传送信息</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110000948763-224901141.png" alt="" loading="lazy"></figure>
<ul>
<li>数据库DAO模式实现类</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001305648-270026570.png" alt="" loading="lazy"></figure>
<p>这里的方法都是对数据库的基本操作，登陆、注册、退出方法无非是加了点判断条件，故不展示。</p>
<ul>
<li>客户端连接到服务器</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001349260-1475308261.png" alt="" loading="lazy"></figure>
<p>参考郑老师提供的JDBCUtil写的客户端连接服务器数据库、用Socket与服务端建立连接，都是基本语句，故不展示。</p>
<p><strong>与服务器进行连接要注意？</strong></p>
<ol>
<li>与MySql连接，要注意MySQLjar包的版本，并根据jar包版本来写URL，如果URL与版本不符合可以根据异常信息去百度处理方法。</li>
<li>用Socket与服务器连接，要注意我们校园网的ip都是内网，所以用某个同学的电脑开着做服务器是不现实的（如果会内网穿透可能可以实现），所以我们在腾讯云上租了一个月的学生服务器，服务器有外网ip，连接起来更简单。【配置服务器环境时需要注意检查安全组是否打开对应端口】</li>
</ol>
<ul>
<li>多个元素封装成一条信息的办法：</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001558900-1648033274.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001523803-530708351.png" alt="" loading="lazy"></figure>
<p>信息Msg都是用Object类型，在考虑如何将多个信息元素一起发送时，一下子就想到“万物皆Object”这句话，利用Object数组也是一个Object可以将多个元素封装成一条信息，这是本次编程过程中让自己惊喜的一个点。</p>
<hr>
<h1 id="五课程设计感想">五.课程设计感想</h1>
<ul>
<li>关于对象流的使用</li>
</ul>
<p>对象流的使用是本次课设困扰我接近24小时的问题。过程中百度了无数办法，碰上了一个又一个异常，最后在郑老师帮助下解决，以下是一点心得，理解可能不到位，希望有人指出。</p>
<ol>
<li>对象流传输的类要序列化（implements Serializable），而且这个类服务器和客户端之间要传输，所以两边的这个类要是一模一样的，否则反序列化时会抛异常，这个最好解决。</li>
<li>在建立对象流时，要谨慎。比如说服务器要先建立输出流再建立输入流，客户端就要先建立输入流再建立输出流。在建立对象流时，不要在最前面建了一个对象流，后面用这个对象流处理传进来的每个对象，这样对象流在第一次反序列化时没有毛病，但是在遇到第二个传进来的对象时，序列化就会出现异常。所以我的解决办法是当要用的时候再去建立一个对象流。</li>
<li>服务器在使用对象流时，要用while循环把ServerSocket的accept包括起来。见博客：https://blog.csdn.net/do_script/article/details/50059049</li>
</ol>
<ul>
<li>关于服务器与客户端数据交互</li>
</ul>
<p>既然可以将多个元素封装成一条信息，也就可以从一条信息读取出多个元素，当然要记得使用instanceof来判断信息类型。服务器与客户端之间收发信息其实不难，而且方法类似，难的是一方在收到信息后要对这条信息做怎样的处理，才能让它传到你想传的地方。</p>
<ul>
<li>关于整个游戏的设计思路</li>
</ul>
<ol>
<li>这次扫雷的最终成果是客户端可以进行扫雷，但是不能看到其他玩家的游戏画面，只能看到他们展开了多少方格，这样多少有点弱化了“对战”，但是时间有限，没有成功将其他人的画面显示出来。<br>
2.原本的思路其实是在其他玩家的面板也放上一个小的扫雷面板，然后在客户端点击一个方格后把这个操作信息发给所有用户，其他用户把收到的这个操作信息作用在该信息对应的扫雷面板上，这样就能让客户端看到其他玩家的操作画面。但是由于我们没能把扫雷面板放在对应的玩家面板上，所以这个想法可以说还没开始就失败了。</li>
</ol>
<p>理想效果（P图实现）：<br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110014117406-81142455.png" alt="" loading="lazy"></p>
<p>实际效果：<br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110014000700-1057066298.png" alt="" loading="lazy"></p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java第09次实验(IO流) - 实验报告]]></title>
        <id>https://damao33.github.io/post/java-di-09-ci-shi-yan-io-liu-shi-yan-bao-gao/</id>
        <link href="https://damao33.github.io/post/java-di-09-ci-shi-yan-io-liu-shi-yan-bao-gao/">
        </link>
        <updated>2019-11-24T14:06:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0-字节流与二进制文件">0. 字节流与二进制文件</h1>
<h3 id="我的代码">我的代码</h3>
<pre><code>
public class Main {
    public static void main(String[] args)
    {
        String fileName=&quot;d:\\testStream\\0\\student.data&quot;;
        try(DataOutputStream dos=new DataOutputStream(new FileOutputStream(fileName)))
        {
        	Student stu1=new Student(1,&quot;zhang&quot;,13,80);
        	dos.writeInt(stu1.getId());
        	dos.writeUTF(stu1.getName());
        	dos.writeInt(stu1.getAge());
        	dos.writeDouble(stu1.getGrade());
        } catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        try(DataInputStream dis=new DataInputStream(new FileInputStream(fileName)))
        {
        	int id=dis.readInt();
        	String name=dis.readUTF();
        	int age=dis.readInt();
        	double grade=dis.readDouble();
        	Student stu=new Student(id,name,age,grade);
        	System.out.println(stu);
        } catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
}
</code></pre>
<h3 id="我的总结">我的总结</h3>
<p>一、 使用DataOutputStream与FileOutputStream将Student对象写入二进制文件student.data</p>
<ol>
<li>二进制文件与文本文件的区别</li>
</ol>
<ul>
<li>二进制文件可以存储int/double/char..等基本数据类型，文本文件只能存储char型变量。因此文本文件在读取或存储过程中常需要用到类型转换（类似parseInt）</li>
</ul>
<p>2.try...catch...finally注意事项</p>
<ul>
<li>catch多个异常时要注意异常写的先后顺序，总体来说越大的（父类）异常要放越后面。可以直接使用eclipse的提示功能直接自己生成异常，方便又不会出错。</li>
</ul>
<p>3.使用try..with...resouces关闭资源</p>
<ul>
<li>是jdk8新的语法，可以直接在try(........)的括号中定义最后要关闭的资源，在运行结束后会自动关闭，不需要传统地在finally中关闭资源。用法详见上面代码块。</li>
</ul>
<hr>
<h1 id="1-字符流与文本文件">1. 字符流与文本文件</h1>
<h3 id="我的代码-2">我的代码</h3>
<p>任务1</p>
<pre><code>String fileName=&quot;d:\\testStream\\1\\Students.txt&quot;;
List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();
		try(
			FileInputStream fis=new FileInputStream(fileName);
			InputStreamReader isr=new InputStreamReader(fis, &quot;UTF-8&quot;);
			BufferedReader br=new BufferedReader(isr))
		{
			String line=null;
			while((line=br.readLine())!=null)
			{
				String[] msg=line.split(&quot;\\s+&quot;);
				int id=Integer.parseInt(msg[0]);
				String name=msg[1];
				int age=Integer.parseInt(msg[2]);
				double grade=Double.parseDouble(msg[3]);
				Student stu=new Student(id,name,age,grade);
				studentList.add(stu);
			}
		} 
		catch (FileNotFoundException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
		catch (IOException e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println(studentList);
</code></pre>
<hr>
<p>任务2</p>
<pre><code>public static List&lt;Student&gt; readStudents(String fileName)
	{
		List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();
		try(
			FileInputStream fis=new FileInputStream(fileName);
			InputStreamReader isr=new InputStreamReader(fis, &quot;UTF-8&quot;);
			BufferedReader br=new BufferedReader(isr))
		{
			String line=null;
			while((line=br.readLine())!=null)
			{
				String[] msg=line.split(&quot;\\s+&quot;);
				int id=Integer.parseInt(msg[0]);
				String name=msg[1];
				int age=Integer.parseInt(msg[2]);
				double grade=Double.parseDouble(msg[3]);
				Student stu=new Student(id,name,age,grade);
				studentList.add(stu);
			}
		} 
		catch (FileNotFoundException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
		catch (IOException e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return studentList;
	}

</code></pre>
<p>任务3</p>
<pre><code>String fileName=&quot;d:\\testStream\\1\\Students.txt&quot;;
try(
			FileOutputStream fos=new FileOutputStream(fileName,true);
			OutputStreamWriter osw=new OutputStreamWriter(fos,&quot;UTF-8&quot;);
			PrintWriter pw=new PrintWriter(osw))
		{
			pw.println();
			pw.print(&quot;4 一一 13 80&quot;);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
</code></pre>
<p>任务4</p>
<pre><code>String fileName1=&quot;d:\\testStream\\1\\Students.dat&quot;;
try(
			FileOutputStream fos=new FileOutputStream(fileName1);
			ObjectOutputStream oos=new ObjectOutputStream(fos))
		{
			Student ts=new Student(5,&quot;asd&quot;,14,60);
			oos.writeObject(ts);
		}
		catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		try(
			FileInputStream fis=new FileInputStream(fileName1);
			ObjectInputStream ois=new ObjectInputStream(fis))
		{
			Student newStudent =(Student)ois.readObject();
			System.out.println(newStudent);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
</code></pre>
<h3 id="我的总结-2">我的总结</h3>
<ul>
<li>在任务1、2、3中，程序生成的txt文件是指定的UTF-8编码。后续如果人为地通过系统自带的文本文档打开Students.txt并进行保存，该文本会变成UTF-8-BOM编码。这样程序再次运行时就会报错，因为指定的UTF-8跟文件实际上的UTF-8-BOM是不一样的，这个问题困扰了我一段时间，目前我的解决方法是两个：不人为保存，或者需要人为保存时用notepad++。</li>
<li>任务3中一开始PrintWriter会直接覆盖原文件，通过查阅资料，在构造FileOutputStream时多传一个true就可以了。</li>
<li>任务4中，一开始是让对象流写在txt中，后面发现会发生乱码。通过查阅资料知道writeObject()的作用是让实例以文件的形式保存在磁盘上，而这个文件是用二进制的形式写的，所以就让对象流的处理文件是bat格式，就没错了。</li>
</ul>
<h1 id="2缓冲流">2.缓冲流</h1>
<h3 id="我的代码-3">我的代码</h3>
<pre><code>
public class Main2 {
	public static void main(String[] args) {
		String fileName=&quot;d:\\testStream\\2\\test.txt&quot;;
		try (PrintWriter pw = new PrintWriter(fileName);)
		{
			Random random=new Random();
			random.setSeed(100);
			double sum=0,aver;
		    for (int i = 0; i &lt; 1000_0000; i++) {
		    	int r=random.nextInt(10);
		    	sum+=r;
		        pw.println(r);
		    }
		    aver=sum/1000_0000;
		    System.out.format(&quot;%.5f&quot;, aver);
		    
		} catch (FileNotFoundException e) {
		    e.printStackTrace();
		}
	}
}
</code></pre>
<p>JUNIT测试部分</p>
<pre><code>
import static org.junit.jupiter.api.Assertions.*;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;

class testBufferedReader {
	String fileName=&quot;d:\\testStream\\2\\test.txt&quot;;
	@Test
	void testScanner() {
		try (	FileInputStream fis = new FileInputStream(fileName);
				Scanner sc=new Scanner(fis))
		{
			while(sc.hasNextInt())
			{
				sc.nextInt();
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}finally
		{
			System.out.println(&quot;sc end&quot;);
		}
	}
	@Test
	void testBufferedReader() {
		try (	FileReader fr = new FileReader(fileName);
				BufferedReader br=new BufferedReader(fr))
		{
			String line=null;
			while((line=br.readLine())!=null)
			{
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}finally
		{
			System.out.println(&quot;br end&quot;);
		}
	}
}

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/1642595/201911/1642595-20191124220608490-910872050.png" alt="" loading="lazy"></figure>
<h3 id="我的总结-3">我的总结</h3>
<ul>
<li>生成随机数平时用的少，每次需要用时都得先找点资料，要尽量记住常见的用法。</li>
<li>在将随机数写入文件时，如果用的是print而不是println，文本大小会是println的三分一（1000_0000字节和3000_0000字节），因为一个回车2字节，没有写回车的话junit跑出来的结果Scanner和BufferedReader的时间是差不多的，而写了回车时间差距就很大。</li>
<li>JUNIT中要测试的方法前要加上@Test</li>
</ul>
<hr>
<h1 id="3字节流之对象流">3.字节流之对象流</h1>
<h3 id="我的代码-4">我的代码</h3>
<pre><code>public static void writeStudent(List&lt;Student&gt; stuList)
	{
		String fileName=&quot;d:\\testStream\\3\\Students.dat&quot;;
		try (	FileOutputStream fos=new FileOutputStream(fileName);
				ObjectOutputStream ois=new ObjectOutputStream(fos))
		{
			ois.writeObject(stuList);
			
		} 
		catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
	}
public static List&lt;Student&gt; readStudents(String fileName)
	{
		List&lt;Student&gt; stuList=new ArrayList&lt;&gt;();
		try (	FileInputStream fis=new FileInputStream(fileName);
				ObjectInputStream ois=new ObjectInputStream(fis))
		{
			stuList=(List&lt;Student&gt;)ois.readObject();
		} 
		catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return stuList;
	}	
</code></pre>
<h3 id="我的总结-4">我的总结</h3>
<ul>
<li>使用对象流时，写入的是一个对象，而不是多个对象。在这里不用像用BufferedReader时一行一个Student对象地读取，而是直接读出一个集合或数组</li>
</ul>
<hr>
<h1 id="5文件操作">5.文件操作</h1>
<h3 id="我的代码-5">我的代码</h3>
<p>递归</p>
<pre><code>
public class Main5 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Path dir=Paths.get(&quot;D:\\&quot;, &quot;testStream&quot;,&quot;5&quot;);
		findFile(dir,&quot;c.txt&quot;);
	}
	public static void findFile(Path dir,String fileName)
	{
		File file=dir.toFile();
		File[] files=file.listFiles();
		for(File now:files)
		{
			if(now.isFile())
			{
				if(now.getName().equals(fileName))
				{
					System.out.println(now.getAbsolutePath());
					return;
				}
			}
			else if(now.isDirectory())
			{
				findFile(now.toPath(),fileName);
			}
		}
	}
}

</code></pre>
<p>队列</p>
<pre><code>
</code></pre>
<h3 id="我的总结-5">我的总结</h3>
<ul>
<li>File类和Path类可以互相转换，Path是File的升级。</li>
<li>Paths类可以直接获得Path对象，不需要new Path。</li>
</ul>
<hr>
<h1 id="6正则表达式">6.正则表达式</h1>
<h3 id="我的代码-6">我的代码</h3>
<p>任务1</p>
<pre><code>
public class Main6 {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		Pattern pattern=Pattern.compile(&quot;^[+-]?[0-9]+(\\.\\d+)?&quot;);
		Matcher matcher=null;
		while(sc.hasNext())
		{
			String str=sc.next();
			matcher=pattern.matcher(str);
			System.out.println(matcher.matches());
		}
		sc.close();
	}
}

</code></pre>
<p>任务2-匹配数字字符串</p>
<pre><code>package javalearning;

import java.io.*;
import java.net.*;
import java.util.regex.*;

/**
 * This program displays all URLs in a web page by matching a regular expression that describes the
 * &lt;a href=...&gt; HTML tag. Start the program as &lt;br&gt;
 * java HrefMatch URL
 * @version 1.01 2004-06-04
 * @author Cay Horstmann
 */
public class HrefMatch
{
   public static void main(String[] args)
   {
      try
      {
         // get URL string from command line or use default
        /* String urlString;
         if (args.length &gt; 0) urlString = args[0];
         else urlString = &quot;http://java.sun.com&quot;;*/
    	 String fileName=&quot;D:\\testStream\\6\\集美大学-计算机工程学院.htm&quot;;
         // open reader for URL
        //InputStreamReader in = new InputStreamReader(new URL(urlString).openStream());
    	 InputStreamReader in = new InputStreamReader(new FileInputStream(fileName));
         // read contents into string builder
         StringBuilder input = new StringBuilder();
         int ch;
         while ((ch = in.read()) != -1)
            input.append((char) ch);

         String patternString = &quot;[+-]?[0-9]+(\\.\\d+)?&quot;;
         Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
         Matcher matcher = pattern.matcher(input);

         while (matcher.find())
         {
            int start = matcher.start();
            int end = matcher.end();
            String match = input.substring(start, end);
            System.out.println(match);
         }
      }
      catch (IOException e)
      {
         e.printStackTrace();
      }
      catch (PatternSyntaxException e)
      {
         e.printStackTrace();
      }
   }
}

</code></pre>
<p>任务2-匹配图片字符串(仅展示部分，其余同数字字符串匹配)</p>
<pre><code>         String patternImgString = &quot;img\\s[a-zA-Z]+=\&quot;.*.(gif|png|jpg|jpeg)\&quot;&quot;;
         Pattern pattern = Pattern.compile(patternImgString, Pattern.CASE_INSENSITIVE);
         Matcher matcher = pattern.matcher(input);
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/1642595/201911/1642595-20191125124157568-132512633.png" alt="" loading="lazy"></figure>
<h3 id="我的总结-6">我的总结</h3>
<ul>
<li>要熟练匹配字符串平时就要多写正则表达式，匹配图片字符串的patternImgString写了一段时间，最后还是没有做到完美的匹配（特殊情况会匹配不准确）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第1次任务-面向对象设计（购物车）]]></title>
        <id>https://damao33.github.io/post/di-1-ci-ren-wu-mian-xiang-dui-xiang-she-ji-gou-wu-che/</id>
        <link href="https://damao33.github.io/post/di-1-ci-ren-wu-mian-xiang-dui-xiang-she-ji-gou-wu-che/">
        </link>
        <updated>2019-09-20T11:50:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第1次任务-面向对象设计购物车">第1次任务-面向对象设计（购物车）</h1>
<h3 id="小组分工">小组分工：</h3>
<ul>
<li>编码规范：叶鸿章</li>
<li>前期调查与功能设计：吴潮汇</li>
<li>面向对象设计与UML制作：张赓</li>
<li>PPT制作、演示：陈伟杰</li>
</ul>
<h3 id="注建议ctrl鼠标滚轮向上以让图片放大看得更清楚">注：建议ctrl+鼠标滚轮向上，以让图片放大看得更清楚</h3>
<hr>
<h2 id="1前期调查">1.前期调查</h2>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190920120649790-774635289.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="2系统功能结构图">2.系统功能结构图</h2>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190920120739398-2133649611.jpg" alt="" loading="lazy"></figure>
<hr>
<h2 id="3系统描述">3.系统描述</h2>
<figure data-type="image" tabindex="3"><img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190920200224965-82720490.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="4uml类图">4.UML类图</h2>
<figure data-type="image" tabindex="4"><img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190920232338850-583276332.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="5面向对象的封装性">5.面向对象的封装性</h2>
<h4 id="体现封装性的几个点">体现封装性的几个点：</h4>
<ol>
<li>
<p>商品类中的属性都设为private，外部无法直接访问到它的属性，只能通过getters来访问<br>
<img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190920233754014-1452485426.png" alt="" loading="lazy"></p>
</li>
<li>
<p>购物车类里的查找函数findByid设为private，因为该查找函数返回的结果只服务于此类里的 增加/移除 等操作，外部没有必要访问到该函数返回值<br>
<img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190920233802142-407098889.png" alt="" loading="lazy"></p>
</li>
<li>
<p>购物车类里的移除方法removeFromMyCart返回的是boolean值，移除成功或失败都不会直接在方法里打印出类似“移除成功”“移除失败”的效果，而是返回true或false的值给外部<br>
<img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190920233810384-469521759.png" alt="" loading="lazy"></p>
</li>
<li>
<p>订单类里的评分/评论方法若直接写在商品类中，可以省去一定代码量，更加容易实现，但不符合逻辑，因为不是“商品给XX评分评论”，而是“用户通过订单对商品评分评价”<br>
<img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190920233819208-1710953.png" alt="" loading="lazy"></p>
</li>
</ol>
<hr>
<h2 id="6项目包结构与主要功能流程图">6.项目包结构与主要功能流程图</h2>
<p>项目包结构：<br>
<img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190920121057734-306054744.png" alt="" loading="lazy"></p>
<p>主要功能流程图：<br>
<img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190920121845683-737647914.png" alt="" loading="lazy"></p>
<hr>
<h2 id="7关键代码">7.关键代码</h2>
<h4 id="购物车类shoppingcart只展示方法">购物车类ShoppingCart（只展示方法）</h4>
<pre><code>public class ShoppingCart {
	
	public void addToMyCart(Commidity commidity) { // 添加商品至购物车
		ItemEntry tem = new ItemEntry(commidity);
		int index = this.findById(commidity.getId());
		if (index == -1) { // 若购物车不存在该商品，则直接增加一条ItemEntry
			this.EntryList.add(tem);	
		} else {// 若购物车存在该商品，直接在对应ItemEntry中数量+1
			this.EntryList.get(index).increase();
		}
	}
	public boolean removeFromMyCart(int id) { // 从购物车中移除商品
		int index = this.findById(id);
		if (index == -1) { // 若购物车不存在该商品，返回false
			return false;
		} else { // 若购物车存在该商品
			if (this.EntryList.get(index).getNum()&gt;1) {
				this.EntryList.get(index).decrease();// 该商品选中数量&gt;1，则对应ItemEntry数量-1
			} else {
				this.EntryList.remove(index);// 该商品选中数量=1，则直接移除对应ItemEntry
			}
			return true;
		}
	}
	/*public void showMyCart() { // 展示购物车
		for(ItemEntry now:EntryList) {
			System.out.println(now.toString());
		}
	}*/
        public ArrayList&lt;ItemEntry&gt; showMyCart() { // 展示购物车
		return this.EntryList;
	}
	public double countTotalPrice() { //计算购物车中所有商品的总价
		for(ItemEntry now:EntryList) {
			totalPrice += now.getPrice();
		}
		return this.totalPrice;
	}
	public void generateOrder(int index) { //生成一条相应订单给user
		ItemEntry tem = this.EntryList.get(index);
		Order order = new Order(tem);
		user.getOrderList().add(order);
		this.totalPrice -= tem.getPrice();//购物车总价减去该订单价格
		this.EntryList.remove(index);//购物车中移除该商品条目
	}
	private int findById(int id) { // 若购物车存在此商品，返回下标；若不存在，返回-1
		int index = -1;
		if ( this.EntryList.size()&gt;0) {
			for(int i = 0; i&lt;this.EntryList.size();i++) {
				if ( this.EntryList.get(i).getItem().getId() == id) {
					index = i;
					break;
				}
			}
		}
		return index;
	}
}
</code></pre>
<h4 id="商品条目类itementry省略settergetter">商品条目类ItemEntry(省略setter/getter)</h4>
<pre><code>public class ItemEntry {// 所选商品的信息
	private Commidity commidity;//商品类，存该商品基本信息
	private double price;//该商品选中数量的总价
	private int num;//该商品选中数量
	public ItemEntry(Commidity commidity){
		this.price = commidity.getPrice();
	}
	public void increase() { // 该条目数量+1
		num++;
		this.price += this.price;//该条目总价改变
	}
	public void decrease() { // 该条目数量-1
		num--;
		this.price -= this.price;//该条目总价改变
	}

}
</code></pre>
<hr>
<h2 id="类功能一览">类功能一览：</h2>
<ul>
<li>
<p>Mall</p>
<ul>
<li>存放所有商品</li>
<li>展示所有商品</li>
<li>移除指定商品</li>
<li>通过id查找商品，查找成功返回下标，否则返回-1</li>
</ul>
</li>
<li>
<p>Commidity</p>
<ul>
<li>初始化商品id编号</li>
<li>存放商品id,库存，单价，买家评分，买家评论</li>
</ul>
</li>
<li>
<p>ItemEntry</p>
<ul>
<li>存放指定商品所选中的数量及选中的数量总价</li>
<li>增加/减少 指定商品选中的数量（1个）</li>
</ul>
</li>
<li>
<p>ShoppingCart</p>
<ul>
<li>存放购物车中商品总价，所选中的商品条目，以及使用该购物车的用户</li>
<li>添加商品至购物车，若该商品不在购物车则新增加一条商品条目，若存在则数量+1</li>
<li>移除商品，若商品不存在则返回false，若存在且数量&gt;1则数量-1，若存在且数量=1则删除该商品条目，并返回true</li>
<li>展示购物车中所有商品</li>
<li>算出购物车中商品总价</li>
<li>生成一条相应订单给用户</li>
<li>通过id在购物车内查找商品，查找成功返回下标，否则返回-1</li>
</ul>
</li>
<li>
<p>User</p>
<ul>
<li>存放用户地址和订单</li>
<li>增加/删除 地址</li>
<li>展示所有订单</li>
<li>删除某条订单</li>
</ul>
</li>
<li>
<p>Order</p>
<ul>
<li>存放商品条目和订单号</li>
<li>自动生成该条订单的订单号</li>
</ul>
</li>
<li>
<p>Address</p>
<ul>
<li>存放地址的省，市，镇</li>
</ul>
</li>
</ul>
<hr>
<h2 id="问题补充">问题补充：</h2>
<h4 id="1addtomycart-返回值用void是否合适">1.addToMyCart 返回值用void是否合适？</h4>
<pre><code>public void addToMyCart(Commidity commidity) { // 添加商品至购物车
		ItemEntry tem = new ItemEntry(commidity);
		int index = this.findByid(commidity.getId());
		if (index == -1) { // 若购物车不存在该商品，则直接增加一条ItemEntry
			this.EntryList.add(tem);	
		} else {// 若购物车存在该商品，直接在对应ItemEntry中数量+1
			this.EntryList.get(index).increase();
		}
	}
</code></pre>
<ul>
<li>addToMyCart（commidity）返回值是void而不是boolean，我们的想法是因为传入的参数commidity就是一个商城中有的商品，所以一定能添加成功，不用判断添加成功或失败而返回true或false，只要判断购物车中是否含有这个商品，如果有就向相应的ItemEntry数量+1，无则向购物车中新增一条新的ItemEntry。一开始有想法让返回值是int，若购物车有此商品返回1，若无返回2，但后来考虑到在前端调用该增加方法时，不论返回1或2，对于用户的结果都是“添加成功”，便还是让返回值是void</li>
</ul>
<h4 id="2showmycart耦合到控制台看看如何解耦">2.showMyCart耦合到控制台，看看如何解耦？</h4>
<pre><code>        /*public void showMyCart() { // 未更改版本的展示购物车
		for(ItemEntry now:EntryList) {
			System.out.println(now.toString());
		}
	}*/
        public ArrayList&lt;ItemEntry&gt; showMyCart() { // 更改后的展示购物车
		return this.EntryList;
	}
</code></pre>
<ul>
<li>耦合我个人的理解是函数之间有相互的联系，解耦就是去弱化这种关系，把方法写得独立点，以免要改一个方法需要触及到其他方法。在这里解耦的方式我们选择不在方法里直接输出，而是直接将购物车中的EntryList返回给前端，让前端去对其进行输出</li>
</ul>
<h4 id="3为什么要itementry类">3.为什么要ItemEntry类？</h4>
<p><img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190921001939688-1747747316.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/201909/1642595-20190921001951417-2041114990.png" alt="" loading="lazy"></p>
<ul>
<li>购物车中的商品，应该包括商品的名称，单价，以及选中的数量（添加至购物车中的件数），选中数量的总价。而原本的商品Commidity类存的是一个商品的基本信息（名称，单价，评分等），因为逻辑上对于一个商品来说，商品并不存在“被选中多少个，一共多少钱”的属性，所以设计了商品条目ItemEntry类，里面除了存放该商品的基本属性外，还放了商品数量、该条目商品总价</li>
</ul>
]]></content>
    </entry>
</feed>