<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://damao33.github.io</id>
    <title>damao_33</title>
    <updated>2020-05-11T05:41:03.501Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://damao33.github.io"/>
    <link rel="self" href="https://damao33.github.io/atom.xml"/>
    <subtitle>汪汪汪汪汪</subtitle>
    <logo>https://damao33.github.io/images/avatar.png</logo>
    <icon>https://damao33.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, damao_33</rights>
    <entry>
        <title type="html"><![CDATA[Java第09次实验(IO流) - 实验报告]]></title>
        <id>https://damao33.github.io/post/java-di-09-ci-shi-yan-io-liu-shi-yan-bao-gao/</id>
        <link href="https://damao33.github.io/post/java-di-09-ci-shi-yan-io-liu-shi-yan-bao-gao/">
        </link>
        <updated>2020-05-11T05:39:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0-字节流与二进制文件">0. 字节流与二进制文件</h1>
<h3 id="我的代码">我的代码</h3>
<pre><code>
public class Main {
    public static void main(String[] args)
    {
        String fileName=&quot;d:\\testStream\\0\\student.data&quot;;
        try(DataOutputStream dos=new DataOutputStream(new FileOutputStream(fileName)))
        {
        	Student stu1=new Student(1,&quot;zhang&quot;,13,80);
        	dos.writeInt(stu1.getId());
        	dos.writeUTF(stu1.getName());
        	dos.writeInt(stu1.getAge());
        	dos.writeDouble(stu1.getGrade());
        } catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        try(DataInputStream dis=new DataInputStream(new FileInputStream(fileName)))
        {
        	int id=dis.readInt();
        	String name=dis.readUTF();
        	int age=dis.readInt();
        	double grade=dis.readDouble();
        	Student stu=new Student(id,name,age,grade);
        	System.out.println(stu);
        } catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
}
</code></pre>
<h3 id="我的总结">我的总结</h3>
<p>一、 使用DataOutputStream与FileOutputStream将Student对象写入二进制文件student.data</p>
<ol>
<li>二进制文件与文本文件的区别</li>
</ol>
<ul>
<li>二进制文件可以存储int/double/char..等基本数据类型，文本文件只能存储char型变量。因此文本文件在读取或存储过程中常需要用到类型转换（类似parseInt）</li>
</ul>
<p>2.try...catch...finally注意事项</p>
<ul>
<li>catch多个异常时要注意异常写的先后顺序，总体来说越大的（父类）异常要放越后面。可以直接使用eclipse的提示功能直接自己生成异常，方便又不会出错。</li>
</ul>
<p>3.使用try..with...resouces关闭资源</p>
<ul>
<li>是jdk8新的语法，可以直接在try(........)的括号中定义最后要关闭的资源，在运行结束后会自动关闭，不需要传统地在finally中关闭资源。用法详见上面代码块。</li>
</ul>
<hr>
<h1 id="1-字符流与文本文件">1. 字符流与文本文件</h1>
<h3 id="我的代码-2">我的代码</h3>
<p>任务1</p>
<pre><code>String fileName=&quot;d:\\testStream\\1\\Students.txt&quot;;
List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();
		try(
			FileInputStream fis=new FileInputStream(fileName);
			InputStreamReader isr=new InputStreamReader(fis, &quot;UTF-8&quot;);
			BufferedReader br=new BufferedReader(isr))
		{
			String line=null;
			while((line=br.readLine())!=null)
			{
				String[] msg=line.split(&quot;\\s+&quot;);
				int id=Integer.parseInt(msg[0]);
				String name=msg[1];
				int age=Integer.parseInt(msg[2]);
				double grade=Double.parseDouble(msg[3]);
				Student stu=new Student(id,name,age,grade);
				studentList.add(stu);
			}
		} 
		catch (FileNotFoundException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
		catch (IOException e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println(studentList);
</code></pre>
<hr>
<p>任务2</p>
<pre><code>public static List&lt;Student&gt; readStudents(String fileName)
	{
		List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();
		try(
			FileInputStream fis=new FileInputStream(fileName);
			InputStreamReader isr=new InputStreamReader(fis, &quot;UTF-8&quot;);
			BufferedReader br=new BufferedReader(isr))
		{
			String line=null;
			while((line=br.readLine())!=null)
			{
				String[] msg=line.split(&quot;\\s+&quot;);
				int id=Integer.parseInt(msg[0]);
				String name=msg[1];
				int age=Integer.parseInt(msg[2]);
				double grade=Double.parseDouble(msg[3]);
				Student stu=new Student(id,name,age,grade);
				studentList.add(stu);
			}
		} 
		catch (FileNotFoundException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		} 
		catch (IOException e) 
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return studentList;
	}

</code></pre>
<p>任务3</p>
<pre><code>String fileName=&quot;d:\\testStream\\1\\Students.txt&quot;;
try(
			FileOutputStream fos=new FileOutputStream(fileName,true);
			OutputStreamWriter osw=new OutputStreamWriter(fos,&quot;UTF-8&quot;);
			PrintWriter pw=new PrintWriter(osw))
		{
			pw.println();
			pw.print(&quot;4 一一 13 80&quot;);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
</code></pre>
<p>任务4</p>
<pre><code>String fileName1=&quot;d:\\testStream\\1\\Students.dat&quot;;
try(
			FileOutputStream fos=new FileOutputStream(fileName1);
			ObjectOutputStream oos=new ObjectOutputStream(fos))
		{
			Student ts=new Student(5,&quot;asd&quot;,14,60);
			oos.writeObject(ts);
		}
		catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		try(
			FileInputStream fis=new FileInputStream(fileName1);
			ObjectInputStream ois=new ObjectInputStream(fis))
		{
			Student newStudent =(Student)ois.readObject();
			System.out.println(newStudent);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
</code></pre>
<h3 id="我的总结-2">我的总结</h3>
<ul>
<li>在任务1、2、3中，程序生成的txt文件是指定的UTF-8编码。后续如果人为地通过系统自带的文本文档打开Students.txt并进行保存，该文本会变成UTF-8-BOM编码。这样程序再次运行时就会报错，因为指定的UTF-8跟文件实际上的UTF-8-BOM是不一样的，这个问题困扰了我一段时间，目前我的解决方法是两个：不人为保存，或者需要人为保存时用notepad++。</li>
<li>任务3中一开始PrintWriter会直接覆盖原文件，通过查阅资料，在构造FileOutputStream时多传一个true就可以了。</li>
<li>任务4中，一开始是让对象流写在txt中，后面发现会发生乱码。通过查阅资料知道writeObject()的作用是让实例以文件的形式保存在磁盘上，而这个文件是用二进制的形式写的，所以就让对象流的处理文件是bat格式，就没错了。</li>
</ul>
<h1 id="2缓冲流">2.缓冲流</h1>
<h3 id="我的代码-3">我的代码</h3>
<pre><code>
public class Main2 {
	public static void main(String[] args) {
		String fileName=&quot;d:\\testStream\\2\\test.txt&quot;;
		try (PrintWriter pw = new PrintWriter(fileName);)
		{
			Random random=new Random();
			random.setSeed(100);
			double sum=0,aver;
		    for (int i = 0; i &lt; 1000_0000; i++) {
		    	int r=random.nextInt(10);
		    	sum+=r;
		        pw.println(r);
		    }
		    aver=sum/1000_0000;
		    System.out.format(&quot;%.5f&quot;, aver);
		    
		} catch (FileNotFoundException e) {
		    e.printStackTrace();
		}
	}
}
</code></pre>
<p>JUNIT测试部分</p>
<pre><code>
import static org.junit.jupiter.api.Assertions.*;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;

class testBufferedReader {
	String fileName=&quot;d:\\testStream\\2\\test.txt&quot;;
	@Test
	void testScanner() {
		try (	FileInputStream fis = new FileInputStream(fileName);
				Scanner sc=new Scanner(fis))
		{
			while(sc.hasNextInt())
			{
				sc.nextInt();
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}finally
		{
			System.out.println(&quot;sc end&quot;);
		}
	}
	@Test
	void testBufferedReader() {
		try (	FileReader fr = new FileReader(fileName);
				BufferedReader br=new BufferedReader(fr))
		{
			String line=null;
			while((line=br.readLine())!=null)
			{
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}finally
		{
			System.out.println(&quot;br end&quot;);
		}
	}
}

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/1642595/201911/1642595-20191124220608490-910872050.png" alt="" loading="lazy"></figure>
<h3 id="我的总结-3">我的总结</h3>
<ul>
<li>生成随机数平时用的少，每次需要用时都得先找点资料，要尽量记住常见的用法。</li>
<li>在将随机数写入文件时，如果用的是print而不是println，文本大小会是println的三分一（1000_0000字节和3000_0000字节），因为一个回车2字节，没有写回车的话junit跑出来的结果Scanner和BufferedReader的时间是差不多的，而写了回车时间差距就很大。</li>
<li>JUNIT中要测试的方法前要加上@Test</li>
</ul>
<hr>
<h1 id="3字节流之对象流">3.字节流之对象流</h1>
<h3 id="我的代码-4">我的代码</h3>
<pre><code>public static void writeStudent(List&lt;Student&gt; stuList)
	{
		String fileName=&quot;d:\\testStream\\3\\Students.dat&quot;;
		try (	FileOutputStream fos=new FileOutputStream(fileName);
				ObjectOutputStream ois=new ObjectOutputStream(fos))
		{
			ois.writeObject(stuList);
			
		} 
		catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
	}
public static List&lt;Student&gt; readStudents(String fileName)
	{
		List&lt;Student&gt; stuList=new ArrayList&lt;&gt;();
		try (	FileInputStream fis=new FileInputStream(fileName);
				ObjectInputStream ois=new ObjectInputStream(fis))
		{
			stuList=(List&lt;Student&gt;)ois.readObject();
		} 
		catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return stuList;
	}	
</code></pre>
<h3 id="我的总结-4">我的总结</h3>
<ul>
<li>使用对象流时，写入的是一个对象，而不是多个对象。在这里不用像用BufferedReader时一行一个Student对象地读取，而是直接读出一个集合或数组</li>
</ul>
<hr>
<h1 id="5文件操作">5.文件操作</h1>
<h3 id="我的代码-5">我的代码</h3>
<p>递归</p>
<pre><code>
public class Main5 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Path dir=Paths.get(&quot;D:\\&quot;, &quot;testStream&quot;,&quot;5&quot;);
		findFile(dir,&quot;c.txt&quot;);
	}
	public static void findFile(Path dir,String fileName)
	{
		File file=dir.toFile();
		File[] files=file.listFiles();
		for(File now:files)
		{
			if(now.isFile())
			{
				if(now.getName().equals(fileName))
				{
					System.out.println(now.getAbsolutePath());
					return;
				}
			}
			else if(now.isDirectory())
			{
				findFile(now.toPath(),fileName);
			}
		}
	}
}

</code></pre>
<p>队列</p>
<pre><code>
</code></pre>
<h3 id="我的总结-5">我的总结</h3>
<ul>
<li>File类和Path类可以互相转换，Path是File的升级。</li>
<li>Paths类可以直接获得Path对象，不需要new Path。</li>
</ul>
<hr>
<h1 id="6正则表达式">6.正则表达式</h1>
<h3 id="我的代码-6">我的代码</h3>
<p>任务1</p>
<pre><code>
public class Main6 {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		Pattern pattern=Pattern.compile(&quot;^[+-]?[0-9]+(\\.\\d+)?&quot;);
		Matcher matcher=null;
		while(sc.hasNext())
		{
			String str=sc.next();
			matcher=pattern.matcher(str);
			System.out.println(matcher.matches());
		}
		sc.close();
	}
}

</code></pre>
<p>任务2-匹配数字字符串</p>
<pre><code>package javalearning;

import java.io.*;
import java.net.*;
import java.util.regex.*;

/**
 * This program displays all URLs in a web page by matching a regular expression that describes the
 * &lt;a href=...&gt; HTML tag. Start the program as &lt;br&gt;
 * java HrefMatch URL
 * @version 1.01 2004-06-04
 * @author Cay Horstmann
 */
public class HrefMatch
{
   public static void main(String[] args)
   {
      try
      {
         // get URL string from command line or use default
        /* String urlString;
         if (args.length &gt; 0) urlString = args[0];
         else urlString = &quot;http://java.sun.com&quot;;*/
    	 String fileName=&quot;D:\\testStream\\6\\集美大学-计算机工程学院.htm&quot;;
         // open reader for URL
        //InputStreamReader in = new InputStreamReader(new URL(urlString).openStream());
    	 InputStreamReader in = new InputStreamReader(new FileInputStream(fileName));
         // read contents into string builder
         StringBuilder input = new StringBuilder();
         int ch;
         while ((ch = in.read()) != -1)
            input.append((char) ch);

         String patternString = &quot;[+-]?[0-9]+(\\.\\d+)?&quot;;
         Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
         Matcher matcher = pattern.matcher(input);

         while (matcher.find())
         {
            int start = matcher.start();
            int end = matcher.end();
            String match = input.substring(start, end);
            System.out.println(match);
         }
      }
      catch (IOException e)
      {
         e.printStackTrace();
      }
      catch (PatternSyntaxException e)
      {
         e.printStackTrace();
      }
   }
}

</code></pre>
<p>任务2-匹配图片字符串(仅展示部分，其余同数字字符串匹配)</p>
<pre><code>         String patternImgString = &quot;img\\s[a-zA-Z]+=\&quot;.*.(gif|png|jpg|jpeg)\&quot;&quot;;
         Pattern pattern = Pattern.compile(patternImgString, Pattern.CASE_INSENSITIVE);
         Matcher matcher = pattern.matcher(input);
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/1642595/201911/1642595-20191125124157568-132512633.png" alt="" loading="lazy"></figure>
<h3 id="我的总结-6">我的总结</h3>
<ul>
<li>要熟练匹配字符串平时就要多写正则表达式，匹配图片字符串的patternImgString写了一段时间，最后还是没有做到完美的匹配（特殊情况会匹配不准确）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用Gridea管理个人博客--简易版]]></title>
        <id>https://damao33.github.io/post/ru-he-shi-yong-gridea-guan-li-ge-ren-bo-ke/</id>
        <link href="https://damao33.github.io/post/ru-he-shi-yong-gridea-guan-li-ge-ren-bo-ke/">
        </link>
        <updated>2020-05-11T04:17:50.000Z</updated>
        <content type="html"><![CDATA[<p>在公众号topbook被安利了Gridea这个写博客的软件后，想起自己又好久没有写博客，于是顺便趁着上手Gridea的机会，好好整顿一下博客</p>
<h2 id="建立github仓库">建立github仓库</h2>
<p>首先到github上创建一个新的仓库，仓库名为 「用户名.github.io」，后续就可以用这个仓库名作为<strong>博客访问域名</strong></p>
<figure data-type="image" tabindex="1"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133416265-1974237194.png" alt="" loading="lazy"></figure>
<p>创建仓库后点击仓库的settings，拉到页面最下端检查自己是否开启了github pages</p>
<p><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133537524-1830869770.png" alt="" loading="lazy"><br>
<img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133600001-1804370455.png" alt="" loading="lazy"></p>
<p>到这里，就成功建立了内容为空的博客页面，访问域名是你的仓库名</p>
<h2 id="建立github-token">建立github token</h2>
<p>点击右上角头像的settings，选择菜单最下面的developer settings</p>
<figure data-type="image" tabindex="2"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133620432-1166258344.png" alt="" loading="lazy"></figure>
<p>选择personal access tokens，并生成一个新的token</p>
<figure data-type="image" tabindex="3"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133634799-1325132850.png" alt="" loading="lazy"></figure>
<p>新建token时填完名称后把repo勾选起来，然后到页面最下面点击生成</p>
<figure data-type="image" tabindex="4"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133642980-772495378.png" alt="" loading="lazy"></figure>
<p>生成成功后，这个页面一定不能关闭，根据提示，你的这个令牌关掉页面后你再也找不到了</p>
<figure data-type="image" tabindex="5"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133651950-1371172610.png" alt="" loading="lazy"></figure>
<h2 id="配置gridea">配置Gridea</h2>
<p>在远程选项里，把能填的信息都填上去，令牌就是你上面生成token获得的个人令牌</p>
<figure data-type="image" tabindex="6"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133659290-333083240.png" alt="" loading="lazy"></figure>
<p>保存后，点击左下角的同步，再通过域名打开你的博客，或者直接点击左下角小地球，就能看到你通过Gridea部署的博客啦</p>
<figure data-type="image" tabindex="7"><img src="https://img2020.cnblogs.com/blog/1642595/202005/1642595-20200511133705466-1843821433.png" alt="" loading="lazy"></figure>
<h2 id="使用gridea">使用Gridea</h2>
<p>关于Gridea的使用还是比较“傻瓜式”的，你可以在清晰简洁的界面里放上你想放的东西，然后点击同步，就可以在博客中看到啦。</p>
<p>Gridea有开放的主题配置环境，你可以在主题商城中选择用户开发或者开发者开发的主题</p>
<p>值得一提的是，Gridea 是一个静态博客写作客户端，所以每次写完内容不要忘记点击同步。</p>
<h2 id="官网">官网</h2>
<p><a href="https://gridea.dev/">https://gridea.dev/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA面向对象编程课程设计——多人扫雷对战]]></title>
        <id>https://damao33.github.io/post/java_mine_sweeper/</id>
        <link href="https://damao33.github.io/post/java_mine_sweeper/">
        </link>
        <updated>2020-05-11T02:29:06.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="一团队课程设计博客链接">一.团队课程设计博客链接</h1>
<p><a href="https://www.cnblogs.com/ye12892/p/12174140.html">JAVA面向对象编程课程设计——多人扫雷对战</a></p>
<h1 id="二个人负责模块和任务说明">二.个人负责模块和任务说明</h1>
<ul>
<li>负责服务器和客户端信息传输</li>
<li>用DAO模式对MySQL进行操作</li>
<li>在客户端将信息在各个界面间传输</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1 id="一团队课程设计博客链接">一.团队课程设计博客链接</h1>
<p><a href="https://www.cnblogs.com/ye12892/p/12174140.html">JAVA面向对象编程课程设计——多人扫雷对战</a></p>
<h1 id="二个人负责模块和任务说明">二.个人负责模块和任务说明</h1>
<ul>
<li>负责服务器和客户端信息传输</li>
<li>用DAO模式对MySQL进行操作</li>
<li>在客户端将信息在各个界面间传输</li>
</ul>
<h2 id="-more-"><!-- more --></h2>
<h1 id="三自己的代码提交记录截图">三.自己的代码提交记录截图</h1>
<p><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110002959991-237554488.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003015038-1477407246.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003016203-1706076234.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110002918055-7983445.png" alt="" loading="lazy"></figure>
<hr>
<h1 id="四自己负责模块或任务详细说明">四.自己负责模块或任务详细说明</h1>
<ul>
<li>客户端登陆、注册、设置信息时和服务器的数据交互：</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003122458-173207921.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003134328-287150250.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003154568-1652655139.png" alt="" loading="lazy"></p>
<p>通过DAO模式将在界面获得的信息与服务器数据库上的信息进行交互，以实现用户登陆、注册、编辑信息的功能。</p>
<ul>
<li>获取游戏操作信息，将玩家的游戏操作传到游戏界面以便于GUI显示：</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003315061-905209868.png" alt="" loading="lazy"></figure>
<p>客户端将点击在哪个方块的信息发送到服务器，服务器将该消息发给所有连接的用户，所有用户收到该消息后在游戏界面对应位置显示出该玩家目前游戏进度。</p>
<ul>
<li>客户端接收到消息时将消息传到相应界面以便于GUI的实时显示：</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110003331635-1150829104.png" alt="" loading="lazy"></figure>
<p>用户每次操作（登陆、进入游戏房间、进行游戏操作、退出等）都会通过服务器发送给所有已连接用户，用户客户端通过判断该操作信息的类型，将该信息传递给对应的GUI面板以便实时显示信息。</p>
<hr>
<p>##主要代码</p>
<ul>
<li>服务器接收并转发信息</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110000802575-1919729382.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110000848061-266985498.png" alt="" loading="lazy"><br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001641969-1208466272.png" alt="" loading="lazy"></p>
<p>服务器端用ServerSocket监听端口，当有用户通过Socket连接时启动一个新的线程来处理该用户发送过来的消息。</p>
<p>**服务器如何获</p>
<!-- more -->
<!-- more -->
<p>得所有已连接用户？**</p>
<p>服务器有一个HashSet型静态属性来存放每个连接进来的线程，而线程有getUser()，通过遍历这个Set就能实现把消息发给所有用户的方法（sendToAll）。</p>
<ul>
<li>客户端接收并向界面传送信息</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110000948763-224901141.png" alt="" loading="lazy"></figure>
<ul>
<li>数据库DAO模式实现类</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001305648-270026570.png" alt="" loading="lazy"></figure>
<p>这里的方法都是对数据库的基本操作，登陆、注册、退出方法无非是加了点判断条件，故不展示。</p>
<ul>
<li>客户端连接到服务器</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001349260-1475308261.png" alt="" loading="lazy"></figure>
<p>参考郑老师提供的JDBCUtil写的客户端连接服务器数据库、用Socket与服务端建立连接，都是基本语句，故不展示。</p>
<p><strong>与服务器进行连接要注意？</strong></p>
<ol>
<li>与MySql连接，要注意MySQLjar包的版本，并根据jar包版本来写URL，如果URL与版本不符合可以根据异常信息去百度处理方法。</li>
<li>用Socket与服务器连接，要注意我们校园网的ip都是内网，所以用某个同学的电脑开着做服务器是不现实的（如果会内网穿透可能可以实现），所以我们在腾讯云上租了一个月的学生服务器，服务器有外网ip，连接起来更简单。【配置服务器环境时需要注意检查安全组是否打开对应端口】</li>
</ol>
<ul>
<li>多个元素封装成一条信息的办法：</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001558900-1648033274.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110001523803-530708351.png" alt="" loading="lazy"></figure>
<p>信息Msg都是用Object类型，在考虑如何将多个信息元素一起发送时，一下子就想到“万物皆Object”这句话，利用Object数组也是一个Object可以将多个元素封装成一条信息，这是本次编程过程中让自己惊喜的一个点。</p>
<hr>
<h1 id="五课程设计感想">五.课程设计感想</h1>
<ul>
<li>关于对象流的使用</li>
</ul>
<p>对象流的使用是本次课设困扰我接近24小时的问题。过程中百度了无数办法，碰上了一个又一个异常，最后在郑老师帮助下解决，以下是一点心得，理解可能不到位，希望有人指出。</p>
<ol>
<li>对象流传输的类要序列化（implements Serializable），而且这个类服务器和客户端之间要传输，所以两边的这个类要是一模一样的，否则反序列化时会抛异常，这个最好解决。</li>
<li>在建立对象流时，要谨慎。比如说服务器要先建立输出流再建立输入流，客户端就要先建立输入流再建立输出流。在建立对象流时，不要在最前面建了一个对象流，后面用这个对象流处理传进来的每个对象，这样对象流在第一次反序列化时没有毛病，但是在遇到第二个传进来的对象时，序列化就会出现异常。所以我的解决办法是当要用的时候再去建立一个对象流。</li>
<li>服务器在使用对象流时，要用while循环把ServerSocket的accept包括起来。见博客：https://blog.csdn.net/do_script/article/details/50059049</li>
</ol>
<ul>
<li>关于服务器与客户端数据交互</li>
</ul>
<p>既然可以将多个元素封装成一条信息，也就可以从一条信息读取出多个元素，当然要记得使用instanceof来判断信息类型。服务器与客户端之间收发信息其实不难，而且方法类似，难的是一方在收到信息后要对这条信息做怎样的处理，才能让它传到你想传的地方。</p>
<ul>
<li>关于整个游戏的设计思路</li>
</ul>
<ol>
<li>这次扫雷的最终成果是客户端可以进行扫雷，但是不能看到其他玩家的游戏画面，只能看到他们展开了多少方格，这样多少有点弱化了“对战”，但是时间有限，没有成功将其他人的画面显示出来。<br>
2.原本的思路其实是在其他玩家的面板也放上一个小的扫雷面板，然后在客户端点击一个方格后把这个操作信息发给所有用户，其他用户把收到的这个操作信息作用在该信息对应的扫雷面板上，这样就能让客户端看到其他玩家的操作画面。但是由于我们没能把扫雷面板放在对应的玩家面板上，所以这个想法可以说还没开始就失败了。</li>
</ol>
<p>理想效果（P图实现）：<br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110014117406-81142455.png" alt="" loading="lazy"></p>
<p>实际效果：<br>
<img src="https://img2018.cnblogs.com/blog/1642595/202001/1642595-20200110014000700-1057066298.png" alt="" loading="lazy"></p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://damao33.github.io/post/hello-gridea/</id>
        <link href="https://damao33.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>